<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Title</title>

    <script crossorigin src="./js/react.development.js"></script>
    <script crossorigin src="./js/react-dom.development.js"></script>
    <script crossorigin src="./js/babel.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@0.6.0/lib/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@0.6.0/lib/addons/p5.dom.js"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

    <link rel="stylesheet" href="./css/bootstrap.css">
    <link rel="stylesheet" href="./css/bootstrap-grid.css">
    <link rel="stylesheet" href="./css/bootstrap-reboot.css">

</head>
<body>

<div id="root"></div>

<script type="text/babel">
    class A extends React.Component {
        constructor(props) {
            super(props);

            this.state = {
                allstocks: [],
                stocks: [],
                learnignRate: 0.0000000000000001,
                optimizer: tf.train.sgd(0.0000000000000001),
                m1: tf.variable(tf.scalar(Math.random(1))),
                m2: tf.variable(tf.scalar(Math.random(1))),
                m3: tf.variable(tf.scalar(Math.random(1))),
                //m4: tf.variable(tf.scalar(Math.random(1))),
                b: tf.variable(tf.scalar(Math.random(1))),
                y: 0,
                y2: 0,
                x1s: [],
                x2s: [],
                x3s: [],
                //x4s: [],
                ys: [],
                run2: 0,
                mingap: 99999999999,
                learning_magnification: 1,
                compute: 0,
            };

            this.getAllStock();
        }

        // 학습할 데이터를 각각의 배열에 담기
        tensorinit = () => {
            this.setState((prevState) => {
                return {
                    x1s: prevState.stocks.map(value => parseInt(value.MMEND_CLSPRC.replace(/,/g , ''))), // 과거 종가
                    x2s: prevState.stocks.map(value => parseInt(value.HGST_CLSPRC.replace(/,/g , ''))), // 과거 최고가
                    x3s: prevState.stocks.map(value => parseInt(value.LWST_CLSPRC.replace(/,/g , ''))), // 과거 최저가
                    //x4s: prevState.stocks.map(value => parseInt(value.AVG_ACC_TRDVOL.replace(/,/g , ''))), // 과거 일평균 거래량
                    //x5s: prevState.stocks.map(value => parseInt(value.AVG_ACC_TRDVAL.replace(/,/g , ''))), // 과거 일평균 거래대금

                    //x6s: prevState.stocks.map(value => parseInt(value.AVG_ACC_TRDVOL.replace(/,/g , ''))), // 현재 일평균 거래량
                    //x7s: prevState.stocks.map(value => parseInt(value.AVG_ACC_TRDVAL.replace(/,/g , ''))), // 현재 일평균 거래대금

                    ys: prevState.stocks.map(value => parseInt(this.state.run2 ? value.LWST_CLSPRC.replace(/,/g , '') : value.HGST_CLSPRC.replace(/,/g , ''))), // 최고가 : 최저
                }
            });

            //this.state.x1s.shift(); // 처음  요소 삭제
            //this.state.x2s.shift(); // 처음  요소 삭제
            //this.state.x3s.shift(); // 처음  요소 삭제
            //this.state.x4s.shift(); // 처음  요소 삭제
            //this.state.x5s.shift(); // 처음  요소 삭제
            //this.state.x6s.shift(); // 처음 요소 삭제
            //this.state.x7s.shift(); // 처음 요소 삭제
            //this.state.ys.shift(); // 처음 요소 삭제

            this.state.x1s.shift(); // 처음  요소 삭제
            this.state.x2s.shift(); // 처음  요소 삭제
            this.state.x3s.shift(); // 처음  요소 삭제
            //this.state.x4s.shift(); // 처음  요소 삭제
            //this.state.x5s.shift(); // 처음  요소 삭제

            //this.state.x6s.pop(); // 처음  요소 삭제
            //this.state.x7s.pop(); // 처음  요소 삭제

            this.state.ys.pop(); // 마지막 요소 삭제

            this.start(); // 계산 시작
        }

        // y 구하는 예측 식
        predict = (x1, x2, x3) => {
            const xs1 = tf.tensor(x1);
            const xs2 = tf.tensor(x2);
            const xs3 = tf.tensor(x3);
            //const xs4 = tf.tensor(x4);

            const mx1 = xs1.mul(this.state.m1);
            const mx2 = xs2.mul(this.state.m2);
            const mx3 = xs3.mul(this.state.m3);
            //const mx4 = xs4.mul(this.state.m4);

            const ys = mx1.add(mx2).add(mx3).add(this.state.b);

            return ys;
        }

        // pred 예측한 값이랑 labels 실제값이랑 차이
        loss = (pred, labels) => pred.sub(labels).square().mean();

        // 학습시작 ( 미니마이져를 하면서 m 값 조절 )
        start = () => {
            tf.tidy(() => {
                for(let i = 0; i < 10; i++) {
                    const ys = tf.tensor(this.state.ys); // 진짜 y
                    this.state.optimizer.minimize(() => this.loss(this.predict(this.state.x1s, this.state.x2s, this.state.x3s), ys));
                }
            });

            this.restart();
        }

        // 예측 알고리즘에 대입하여 gap 에 따라 러닝배율 조절
        restart = () => {
            // predict_y : 학습데이터의 예측값
            // ys : 학습데이터의 실제 값
            // y : 실제 데이터를 넣어 예측해보는 값

            let predict_y = Number(String(this.predict(parseFloat(this.state.x1s[0]),parseFloat(this.state.x2s[0]),parseFloat(this.state.x3s[0]))).replace('Tensor','').replace(/a/gi,""));
            let gap = Math.abs(predict_y - this.state.ys[0]);

            let x1 = parseFloat(this.state.stocks[1].MMEND_CLSPRC.replace(/,/g, '')); // 예측해야 될 데이터
            let x2 = parseFloat(this.state.stocks[1].HGST_CLSPRC.replace(/,/g, '')); // 예측해야 될 데이터
            let x3 = parseFloat(this.state.stocks[1].LWST_CLSPRC.replace(/,/g, '')); // 예측해야 될 데이터



            if(this.state.mingap > gap) {
                let gap2 = Math.abs(this.state.mingap - gap);

                this.setState((prevState) => {
                    let t = 1;
                    if(gap > 1000) {
                        t = 1.4;
                    } else if(gap > 100) {
                        t = 1.3;
                    } else if(gap > 10) {
                        t = 1.2;
                    } else if(gap > 1) {
                        t = 1.1;
                    } else if(gap > 0.1) {
                        t = 1;
                    }
                    return {
                        learning_magnification: t,
                    }
                });

                // 실시간 데이터 변경
                this.setState((prevState) => {
                    if(this.state.run2 == 2) {
                        return {
                            mingap: prevState.mingap < gap ? prevState.mingap : gap,
                            learnignRate: prevState.learnignRate * this.state.learning_magnification,
                            // 진짜 예측
                            y2: Number(String(this.predict(x1,x2,x3)).replace('Tensor','').replace(/a/gi,"")),
                            optimizer: tf.train.sgd(this.state.learnignRate),
                            compute: prevState.compute+1,
                        }
                    } else {
                        return {
                            mingap: prevState.mingap < gap ? prevState.mingap : gap,
                            learnignRate: prevState.learnignRate * this.state.learning_magnification,
                            y: Number(String(this.predict(x1,x2,x3)).replace('Tensor','').replace(/a/gi,"")),
                            optimizer: tf.train.sgd(this.state.learnignRate),
                            compute: prevState.compute+1,
                        }
                    }
                });

                console.log("mingap : " + this.state.mingap);
                console.log("gap (predict_y - ys) : " + gap);
                console.log("gap2 (mingap - gao) : " + gap2);
                //console.log(predict_y + " - " + this.state.ys[0] + " = " + gap);


                console.log("predict_y (학습데이터의 예측값 값) : " + Number(String(this.predict(x1,x2,x3)).replace('Tensor','').replace(/a/gi,"")));
                console.log("ys (학습데이터의 실제 값 값) : " + this.state.ys[0]);

                console.log("y (예측해보는 값) : " + Number(String(this.predict(x1,x2,x3)).replace('Tensor','').replace(/a/gi,"")));

                console.log("==========================");
                //console.log("learnignRate : " + this.state.learnignRate);

                setTimeout(() => this.start(), 1);
            } else if (this.state.compute < 5) {
                // 혹시 너무 빨리 끝났다면 다시 계산
                this.setState((prevState) => {
                    return {
                        learnignRate: prevState.learnignRate * 10,
                        optimizer: tf.train.sgd(prevState.learnignRate * 10),
                        m1: tf.variable(tf.scalar(Math.random(1))),
                        m2: tf.variable(tf.scalar(Math.random(1))),
                        m3: tf.variable(tf.scalar(Math.random(1))),
                        b: tf.variable(tf.scalar(Math.random(1))),
                        run2: prevState.run2,
                        mingap: 99999999999,
                        compute: 0,
                    }
                });

                setTimeout(() => this.start(), 1);

            } else if(this.state.run2 == 0) {
                // 최고가 계산후
                this.setState((prevState) => {
                    return {
                        learnignRate: 0.0000000000000001,
                        optimizer: tf.train.sgd(0.0000000000000001),
                        m1: tf.variable(tf.scalar(Math.random(1))),
                        m2: tf.variable(tf.scalar(Math.random(1))),
                        m3: tf.variable(tf.scalar(Math.random(1))),
                        b: tf.variable(tf.scalar(Math.random(1))),
                        x1s: [],
                        x2s: [],
                        x3s: [],
                        ys: [],
                        run2: 2,
                        mingap: 99999999999,
                        compute: 0,
                    }
                });

                this.tensorinit();
            }
        }

        // 오늘 기준으로 년도 변경
        getCurrentDate = (_year = 0) => {
            let date = new Date();
            date.setFullYear(date.getFullYear() - _year);

            let year = date.getFullYear().toString();
            let month = date.getMonth() + 1;
            month = month < 10 ? '0' + month.toString() : month.toString();
            //let day = date.getDate();
            //day = day < 10 ? '0' + day.toString() : day.toString();
            return year + month;
        }

        // 날짜를 년 월로 표기
        dateToKo = (str) => {
            return str.substring(0,4) + '년 ' + str.substring(5,6) + '월';
        }

        // 전종목 기본정보
        getAllStock = () => {
            let request = new XMLHttpRequest();

            request.open('GET', 'https://yg01.herokuapp.com/http://data.krx.co.kr/comm/bldAttendant/getJsonData.cmd?bld=dbms/MDC/STAT/standard/MDCSTAT01901&mktId=ALL', true);
            request.onload = (e) => {
                if (request.status >= 200 && request.status < 400) {
                    let responseObject = JSON.parse(request.responseText);
                    this.setState((prevState) => {
                        return {
                            allstocks: responseObject.OutBlock_1,
                        }
                    });
                } else {
                    console.log('We reached our target server, but it returned an error');
                    console.log('Possibly handle the error by changing your state.');
                }
            };

            request.onerror = () => {
                console.log('There was a connection error of some sort.');
                console.log('Possibly handle the error by changing your state.');
            };

            request.send();
        }

        // 개별종목 시세추이 (월)
        getData = (isuCd) => {
            let request = new XMLHttpRequest();

            request.open('GET', 'https://yg01.herokuapp.com/http://data.krx.co.kr/comm/bldAttendant/getJsonData.cmd?' +
                'bld=dbms/MDC/STAT/standard/MDCSTAT01801&' +
                'isuCd='+isuCd+'&' +
                'strtYymm=' + this.getCurrentDate(5) + '&' +
                'endYymm=' + this.getCurrentDate() + '&', true);
            request.onload = (e) => {
                if (request.status >= 200 && request.status < 400) {
                    let responseObject = JSON.parse(request.responseText);
                    this.setState((prevState) => {
                        return {
                            stocks: responseObject.OutBlock_1,
                        }
                    });
                    setTimeout(() => {
                        this.state.stocks.shift();
                        this.tensorinit();
                    }, 100);
                } else {
                    console.log('We reached our target server, but it returned an error');
                    console.log('Possibly handle the error by changing your state.');
                }
            };

            request.onerror = () => {
                console.log('There was a connection error of some sort.');
                console.log('Possibly handle the error by changing your state.');
            };

            request.send();
        }

        onChange = (e) => {
            // 셀렉트 박스 변경시 완전히 초기화
            this.setState((prevState) => {
                return {
                    stocks: [],
                    learnignRate: 0.0000000000000001,
                    optimizer: tf.train.sgd(0.0000000000000001),
                    y: 0,
                    y2: 0,
                    m1: tf.variable(tf.scalar(Math.random(1))),
                    m2: tf.variable(tf.scalar(Math.random(1))),
                    m3: tf.variable(tf.scalar(Math.random(1))),
                    b: tf.variable(tf.scalar(Math.random(1))),
                    x1s: [],
                    x2s: [],
                    x3s: [],
                    ys: [],
                    run2: 0,
                    mingap: 99999999999,
                    compute: 0,
                }
            });

            this.getData(e.target.value);
        }

        render() {
            return (<div>
                <select onChange={this.onChange}>
                    {this.state.allstocks.map((stock, idx) => {
                        return (
                            <option value={stock.ISU_CD} key={idx}>{stock.ISU_NM}</option>
                        )
                    })}
                </select>
                <p>{this.dateToKo(this.getCurrentDate())} 최고가 예측 : {this.state.y}</p>
                <p>{this.dateToKo(this.getCurrentDate())} 최저가 예측 : {this.state.y2}</p>
                <table className="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th rowSpan="2">연월(TRD_DD)</th>
                            <th rowSpan="2">종가(MMEND_CLSPRC)</th>
                            <th rowSpan="2">최고가(HGST_CLSPRC)</th>
                            <th rowSpan="2">최저가(LWST_CLSPRC)</th>
                            <th colSpan="2">거래량</th>
                            <th colSpan="2">거래대금</th>
                        </tr>
                        <tr>
                            <th>합계(MM_ACC_TRDVOL)</th>
                            <th>일평균(AVG_ACC_TRDVOL)</th>
                            <th>합계(MM_ACC_TRDVAL)</th>
                            <th>일평균(AVG_ACC_TRDVAL)</th>
                        </tr>
                    </thead>
                    <tbody>
                        {this.state.stocks.map((stock, idx) => {
                            return (
                                <tr key={idx}>
                                    <td>{stock.TRD_DD}</td>
                                    <td>{stock.MMEND_CLSPRC}</td>
                                    <td>{stock.HGST_CLSPRC}</td>
                                    <td>{stock.LWST_CLSPRC}</td>
                                    <td>{stock.MM_ACC_TRDVOL}</td>
                                    <td>{stock.AVG_ACC_TRDVOL}</td>
                                    <td>{stock.MM_ACC_TRDVAL}</td>
                                    <td>{stock.AVG_ACC_TRDVAL}</td>
                                </tr>
                            )
                        })}
                    </tbody>
                </table>
            </div>);
        }
    }

</script>

<script type="text/babel">
    ReactDOM.render(<A />, document.querySelector('#root'));
</script>
</body>
</html>